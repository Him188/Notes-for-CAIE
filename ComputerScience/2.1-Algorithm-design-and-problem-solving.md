# 2.1 Algorithm design and problem-sovling

## 2.1.1 Algorithms
> - show understanding that an algorithm is a solution to a problem expressed as a sequence of defined steps
> - use suitable identifier names for the representation of data used by a problem
>   - summarise identifier names using an identifier table
> - show understanding that many algorithms are expressed using the four basic constructs of assignment, sequence, selection and repetition
> - show understanding that simple algorithms consist of input, process, output at various stages
> - document a simple algorithm using:
>   - structured English
>   - pseudocode (on the examination paper, any given pseudocode will be presented using the Courier New font)
>   - program flowchart 
> - derive pseudocode or a program flowchart from a structured English description of a problem
> - derive pseudocode from a given program flowchart or vice versa
> - use the process of stepwise refinement to express an algorithm to a level of detail from which the task may be programmed
> - decompose a problem into sub-tasks leading to the concept of a program module (procedure/function)
> - show an appreciation of why logic statements are used to define parts of an algorithm solution
> - use logic statements to define parts of an algorithm solution

### Step-wise refinement
> s19 23 Q2 \[3\]

- The breaking down of an algorithm
- to a level of sub-tasks
- from which it can be programmed

## 2.1.2 Structure chart
> - use a structure chart to express the parameters passed between the various modules/procedures/functions which are part of the algorithm design
> - describe the purpose of a structure chart
> - construct a structure chart for a given problem
> - derive equivalent pseudocode from a structure chart

#### Features \[4\]

- Module **hierarchy**
- The parameters that are passed
- The **sequence** of module execution
- Selection and Iteration

## 2.1.3 Corrective maintenance
> - perform white-box testing by:
>   - selecting suitable data
>   - using a trace table
> - identify any error(s) in the algorithm by using the completed trace table amend the algorithm if required

### White-box testing
> s19 23 Q5 \[1\]
To test **every path** through the code

## 2.1.4 Adaptive maintenance
> - make amendments to an algorithm and data structure in response to specification changes
> - analyse an existing program and make amendments to enhance functionality

`Adaptive maintenance`:
Updating a program as a result of changes to requirements
